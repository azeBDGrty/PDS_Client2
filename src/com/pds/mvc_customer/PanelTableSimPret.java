/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.pds.mvc_customer;

import com.pds.entities.Client;
import com.pds.entities.MathHepler;
import com.pds.entities.SimulationPret;
import com.pds.implobs.AbstractObservable;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import java.util.function.Consumer;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author zouhairhajji
 */
public class PanelTableSimPret extends javax.swing.JInternalFrame implements com.pds.implobs.IObserver {

    private Client client;
    private LinkedList<SimulationPret> listSimPretConcerned;
    private Controller_GestClient controller;
    private double coefs[];
    
    /**
     * Creates new form PanelTableSimPret
     */
    

    PanelTableSimPret(Controller_GestClient controller) {
        this.controller = controller;
        this.coefs = new double[]{6,5,4,3,2,1};
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {
                    ""

                }},
                new String [] {
                    "Identifiant de la simulation", "Mensualité", "Durée", "Taux d'interet", "Montant totale", "Type de prêt", "Taux d'endettement", "Resultat", "Position"
                }
            ));
            jScrollPane1.setViewportView(jTable1);

            jLabel1.setText("Le tri intéligent des simulations");

            javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
            getContentPane().setLayout(layout);
            layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addContainerGap()
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 759, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(layout.createSequentialGroup()
                            .addGap(233, 233, 233)
                            .addComponent(jLabel1)))
                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            );
            layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                    .addGap(34, 34, 34)
                    .addComponent(jLabel1)
                    .addGap(50, 50, 50)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            );

            pack();
        }// </editor-fold>//GEN-END:initComponents


    
    void chargerSimulations(Client client, List<SimulationPret> listSimPret) throws CloneNotSupportedException {
        this.client = client;
        this.listSimPretConcerned = new LinkedList<>();
        DefaultTableModel tableModel = (DefaultTableModel) jTable1.getModel();
        tableModel.setRowCount(0);
        /*
        listSimPret.stream()
                .sorted(
                        (e1, e2) -> MathHepler.compareToWithTauxEndet(client, e1, e2, true)
                                //Double.compare(
                                //e1.getTauxEndettement(client), e2.getTauxEndettement(client))
                )
                .forEach(e -> listSimPretConcerned.add(e));
        */
        
        int pMensualite = -1;
        int pDuree = -1;
        int pTauxInteret = -1;
        int pMtTotal = -1;
        int pTypePret = -1;
        int pTauxEndettement = -1;
        double resultat = -1;
        int position = 0;
        List<Object[]> dataSimulations = new LinkedList<>();
        
        
        for(int i = 0; i<listSimPret.size() ;i++){         
            pMensualite = getPosMensualite(listSimPret, listSimPret.get(i));
            pDuree = getPosDuree(listSimPret, listSimPret.get(i));
            pTauxInteret = getPosTauxInteret(listSimPret, listSimPret.get(i));
            pMtTotal = getPosMensualite(listSimPret, listSimPret.get(i)) ;
            pTypePret = getPosTypePret(listSimPret, listSimPret.get(i)) ;
            pTauxEndettement = getPosTauxEndett(listSimPret, listSimPret.get(i));   
            resultat =   getResultat(pMensualite, pDuree, pTauxInteret, pMtTotal, pTypePret, pTauxEndettement);
            
            Object[] objects = new Object[]{
                "Idenfiant :"+listSimPret.get(i).getIdSimPret(),
                MathHepler.ajustVirgule(listSimPret.get(i).getMensualite(), 2)+ " €",
                listSimPret.get(i).getDureePret()+ " mois",
                MathHepler.ajustVirgule(listSimPret.get(i).getTauxInteret(), 2)+" %",
                MathHepler.ajustVirgule(listSimPret.get(i).getMensualite()*listSimPret.get(i).getDureePret(), 2)+ " €",
                listSimPret.get(i).getTypePret().getAbv(),
                MathHepler.ajustVirgule(listSimPret.get(i).getTauxEndettement(client)*100, 2)+" %",
                resultat, 
                -1
            };
            dataSimulations.add(objects); 
        }
        
        Collections.sort(dataSimulations, new Comparator<Object[]>(){
            @Override
            public int compare(Object[] o1, Object[] o2) {
                return MathHepler.compareToResSimulation(o1, o2, true);
            }
        });
        
        for(int i = 0; i<dataSimulations.size() ;i++){
            dataSimulations.get(i)[8] = (i+1);
            tableModel.addRow(dataSimulations.get(i));
        }
        
        
        
        /*
        Object[] objects = new Object[]{
                "Idenfiant :"+simulation.getIdSimPret(),
                MathHepler.ajustVirgule(simulation.getMensualite(), 2)+ " €",
                simulation.getDureePret()+ " mois",
                MathHepler.ajustVirgule(simulation.getTauxInteret(), 2)+" %",
                MathHepler.ajustVirgule(simulation.getMensualite()*simulation.getDureePret(), 2)+ " €",
                simulation.getTypePret().getAbv(),
                MathHepler.ajustVirgule(simulation.getTauxEndettement(client)*100, 2)+" %",
                MathHepler.ajustVirgule(resultat, 2)+" points"
            };
            tableModel.addRow(objects);
         */
        
            
        this.repaint();
        this.validate();
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    // End of variables declaration//GEN-END:variables


    public  double getResultat(double pMensualite, double pDuree, double pTauxInteret, double pMtTotal, double pTypePret, double pTauxEndettement){
        return (pMensualite * coefs[0] + pDuree* coefs[1] + pTauxInteret* coefs[2] + pMtTotal* coefs[3] + pTypePret* coefs[4]+ pTauxEndettement* coefs[5]);
    }
    
    
    
    public int getPosMensualite(List<SimulationPret> listSimulation, SimulationPret simulationConcerned){
        int position = 1;
        List<SimulationPret> simulations = new LinkedList<>();
        
        listSimulation.stream()
                .sorted(
                        (e1, e2) -> MathHepler.compareToWithMensualite(e1, e2, false)
                ).forEach(e -> simulations.add(e));
        
        return simulations.indexOf(simulationConcerned);
    }
    
    
    public int getPosDuree(List<SimulationPret> listSimulation, SimulationPret simulationConcerned){
        int position = 1;
        List<SimulationPret> simulations = new LinkedList<>();
        
        listSimulation.stream()
                .sorted(
                        (e1, e2) -> MathHepler.compareToWithDuree(e1, e2, false)
                ).forEach(e -> simulations.add(e));
        
        return simulations.indexOf(simulationConcerned);
    }
    
    
    public int getPosTauxInteret(List<SimulationPret> listSimulation, SimulationPret simulationConcerned){
        int position = 1;
        List<SimulationPret> simulations = new LinkedList<>();
        
        listSimulation.stream()
                .sorted(
                        (e1, e2) -> MathHepler.compareToInteret(e1, e2, false)
                ).forEach(e -> simulations.add(e));
        
        return simulations.indexOf(simulationConcerned);
    }
    
    
    public int getPosMtTotal(List<SimulationPret> listSimulation, SimulationPret simulationConcerned){
        int position = 1;
        List<SimulationPret> simulations = new LinkedList<>();
        
        listSimulation.stream()
                .sorted(
                        (e1, e2) -> MathHepler.compareToMtTotale(e1, e2, false)
                ).forEach(e -> simulations.add(e));
        
        return simulations.indexOf(simulationConcerned);
    }
    
    
    public int getPosTypePret(List<SimulationPret> listSimulation, SimulationPret simulationConcerned){
        int position = 1;
        List<SimulationPret> simulations = new LinkedList<>();
        
        listSimulation.stream()
                .sorted(
                        (e1, e2) -> MathHepler.compareToTypePret(e1, e2, false)
                ).forEach(e -> simulations.add(e));
        
        return simulations.indexOf(simulationConcerned);
    }
    
    
    public int getPosTauxEndett(List<SimulationPret> listSimulation, SimulationPret simulationConcerned){
        int position = 1;
        List<SimulationPret> simulations = new LinkedList<>();
        
        listSimulation.stream()
                .sorted(
                        (e1, e2) -> MathHepler.compareToWithTauxEndet(client, e1, e2, false)
                ).forEach(e -> simulations.add(e));
        
        return simulations.indexOf(simulationConcerned);
    }
    
    public int getPosResSimPret (List<Object[]> listSimulation, SimulationPret simulationConcerned){
        int position = 1;
        List<Object[]> simulations = new LinkedList<>();
        
        listSimulation.stream()
                .sorted(
                        (e1, e2) -> MathHepler.compareToResSimulation( e1, e2, false)
                ).forEach(e -> simulations.add(e));
        
        return simulations.indexOf(simulationConcerned);
    }
    
    
    
    @Override
    public boolean update(AbstractObservable sender, String message, Object... data) {
        return true;
    }
}
